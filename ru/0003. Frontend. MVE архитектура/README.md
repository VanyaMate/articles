# Frontend. MVA архитектура

Здравствуйте.

Из этой статьи вы узнаете об определенном архитектурном подходе, который я назвал **MVA** (для себя).

Вы, возможно, узнаете в данном подходе **Flux** или **MVI**, но я считаю, что это что-то другое. Почему - в конце.

Так же весь код считайте псевдокодом.

****

## План

1. Предисловие
2. Архитектура MVA
3. Отличия от других архитектур
4. Плюсы / Минусы
5. Инструменты
6. Вариант реализации / Простой пример

## Предисловие

Перед тем как начать, важно понимать пару вещей которые я для себя решил считать верными и следую им.

1.

Архитектуры, библиотеки, фреймворки, принципы, тестирование, итд. - это инструменты и у каждого есть своя область
применения, свои плюсы и минусы, своя цена итд.

- Какие-то инструменты много весят, но дают большой функционал.
- Какие-то дают вам удобство, но забирают производительность.
- Какие-то ограничивают вас, но делают проект легко изменяемым.
- Какие-то забирают больше времени, но делают так что проект не умрет через день.
- итд.

И каждый инструмент нужен тогда когда нужен именно такой инструмент. Как бы это очевидно не звучало.

2.

Так же я всегда стараюсь всё максимально упростить с точки зрения абстрактности, чтобы уместить приложение в голове
целиком, каким бы большим оно не было.

Сделать сложно - очень просто, но сделать просто - очень сложно.

****

## Архитектура MVA

**MVA** это способ организации кода который предполагает выделение трех сущностей и связь между ними.

1. **Model** - хранилище данных с самообновлением
2. **View** - представление данных
3. **Action** - самодостаточное действие

![img.png](img.png)

Что такое **Effect** - узнаем чуть дальше.

### Сущности

Разберем каждую сущность по отдельности и определим их задачи.

#### Model

Вся задача **Model** сводится к тому, чтобы подписаться на действия и самообновляться.

То есть никто кроме самой **Model** не может обновить её.

#### View

Задача **View** сводится к рендеру данных и вызову действий.

Для удобства так же разделяем **View** на [два типа компонентов](https://habr.com/ru/articles/784172/) одни из которых
(shared, entity) ни от чего не зависят, а вторые (feature, widget) уже и подписываются на **Model** и вызывают
**Effect**.

#### Action

Что такое действия? Действия могут быть чем угодно. Это может быть
функция входа в аккаунт `signIn (login: string, password: string): Promise<AuthData>`, это может быть функция загрузки
постов `getPosts (userId: string, options: SearchOptions): Promise<Array<Post>>` или функция, чтобы оставить комментарий
`sendCommentary (postId: string, commentary: string): Promise<Commentary>`.

****

В итоге мы имеем три разные сущности которые, по сути, могут независимо (почти) разрабатываться разными людьми и
тестироваться. Единственное, что при разработке моделей нужно знать сигнатуры действий, но их типы можно
выделить сразу.

### Связи

Теперь разберем как связаны эти сущности друг с другом.

#### **View** -> **Model**

**View** подписывается на **Model**, отслеживает изменения и самообновляется.

#### **Model** -> **Effect**

**Effect** это обертка над **Action**. Эта обертка сохраняет сигнатуру, а так же создает независимый экземпляр функции
на которую можно подписаться из **Model**. Почему так? Почему подписываться не сразу на **Action**?

Допустим у нас есть **Action** `getUser (userId: string): Promise<User>`. Это действие мы можем хотеть использовать во
многих местах нашего приложения. Например, для получения данных для рендера главной страницы пользователя или же для
получения данных для показа их в выпадающем окне при наведении итд. И для этих задач у нас будут созданы две разные
модели, одна для главной страницы, одна для выпадающего окна. Но обе они будут подписаны на одно и тоже. Получается, что
при вызове этого действия - обновляться будут обе модели, а мы, скорее всего, этого не хотим.

По этому мы создаем **Effect**-ы (обертку над **Action**)

```typescript
const getUserPageData    = effect(getUser);
const getUserPopOverData = effect(getUser);
```

Получаем один и тот же функционал, но разные эффекты, а следовательно проблемы с тем, что модель будет обновляться
тогда когда не нужно - не будет.

#### **Effect** -> **Action**

Это собственно обертка над **Action** которая служит для того о чем мы говорили до.

## Отличия от других архитектур

Теперь разберем отличия от **Flux**, **MVI** и допустим **MVC**.

Ps. Читая про разные архитектуры, про их суть, можно часто заметить, что разные люди, разные источники, трактуют их по
своему. Но как мне кажется, я понял их суть и я буду отталкиваться от своего понимания, которое, разумеется, может быть
отличным от вашего или вовсе не верным.

### Flux

С **Flux** вообще интересно, потому что они вроде бы похожи, но вообще разные.
И там и там однонаправленный поток данных (в чем похожи), но реализация архитектуры - разная.
Основное отличие от **Flux** это отсутствие *Dispatcher*.

Тут, для меня, действительно сложно, потому что в зависимости от того как посмотреть - она может быть то похожа, то
совсем другой. Но главным аргументом для меня в пользу того, что они разные - является то, что если попробовать
перенести то как делаю я в **MVA** на **Flux** - получается всё гораздо сложнее и не понятно зачем.

### MVI

С **MVI** достаточно просто. Там я нашел 2 варианта трактовки и оба они отличаются от **MVA**.

1. Действия в **MVI** сами обновляют модель. Модель не подписывается на действия.
2. Действия в **MVI** сами отправляют данные в модель которые та уже сама как-то обновляет.

### MVC

Казалось бы, причем тут **MVC**? Но под прошлой статьй на эту же тему кто-то написал, про "Опять изобрели MVC" и на
всякий случай разберем и это.

В **MVC** всем рулит *Controller*. Он является связью между *View* и *Model*. Опять же, можно всё трактовать по-разному.
Где-то вы прочтете, что *Controller* контролирует только *Model*, а *View* на его подписывается, кто-то допускает связь
между *View* и *Model* на прямую итд.

****

На самом деле не важно как это всё называется, придумал ли я что-то новое или нет.

Я пришел к определенному архитектурному подходу и сам для себя его назвал **MVA**. После решил поискать нечто подобное и
точно такого же не нашел. Решил поделиться, потому что считаю его очень удобным и простым.

## Плюсы / Минусы

### Плюсы

Основной плюс подхода - его простота.

1. Ничего не запутанно, всё находится на своих местах и благодаря простой структуре можно легко понимать устройство
   всего приложения целиком вне зависимости от его размера.
2. Так как вам нужно совсем маленькое количество функционала для реализации архитектуры - вам не нужны тяжеловесные
   реализации глобальных хранилищ.
